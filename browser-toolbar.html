<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cobalt</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    .browser-toolbar {
      position: fixed;
      top: 32px; /* Tab bar Î∞îÎ°ú ÏïÑÎûò */
      left: 0;
      width: 75%; /* ÏôºÏ™Ω 75% - BrowserView ÏòÅÏó≠ */
      height: 40px;
      background: #fff;
      border-bottom: 1px solid #dadce0;
      display: flex;
      align-items: center;
      padding: 0 8px;
      gap: 8px;
      z-index: 10000;
    }

    .nav-button {
      width: 32px;
      height: 32px;
      border: none;
      background: transparent;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #5f6368;
      font-size: 24px;
      font-weight: 300;
      transition: background 0.15s, transform 0.1s;
    }

    .nav-button:hover:not(:disabled) {
      background: #e8eaed;
      transform: scale(1.05);
    }

    .nav-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .nav-button:active:not(:disabled) {
      background: #dadce0;
      transform: scale(0.95);
    }

    .url-container {
      flex: 1;
      display: flex;
      align-items: center;
      background: #fff;
      border: 1px solid #e0e3e7;
      border-radius: 20px;
      padding: 0 12px;
      height: 38px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }

    .url-container.open {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom-color: transparent;
      box-shadow: 0 6px 16px rgba(32,33,36,.18);
    }

    .url-container:focus-within {
      background: #fff;
      box-shadow: 0 4px 16px rgba(32,33,36,.18);
      border-color: #c7d2fe;
    }

    /* Disabled state when AI controls navigation */
    .url-container.disabled {
      opacity: 0.6;
      pointer-events: none;
    }
    .url-input:disabled {
      background: #f3f4f6;
      cursor: not-allowed;
      color: #9aa0a6;
    }

    .url-input {
      flex: 1;
      border: none;
      outline: none;
      font-size: 14px;
      color: #202124;
      background: transparent;
      padding: 0 6px;
    }

    .url-icon {
      margin-right: 6px;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      color: #5f6368;
    }

    .url-icon svg {
      width: 16px;
      height: 16px;
    }

    /* Omnibox dropdown (history/suggestions) */
    .omnibox-dropdown {
      position: fixed;
      top: 72px; /* default under tab(32) + toolbar(40); will be repositioned in JS */
      left: 8px;
      width: 50%;
      max-height: 280px;
      overflow: auto;
      background: #fff;
      border: 1px solid #dadce0;
      border-top: none;
      border-radius: 0 0 12px 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      z-index: 10002; /* Above toolbar/status bar */
    }
    .omnibox-dropdown.hidden { display: none; }
    .omnibox-item {
      padding: 10px 14px;
      font-size: 13px;
      color: #202124;
      cursor: pointer;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .omnibox-item:hover { background: #f1f3f4; }
    .omnibox-item .title { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .omnibox-item .url { color: #5f6368; font-size: 12px; }

    .chat-toggle-btn {
      border: none;
      background: white;
      border-radius: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 14px;
      margin-left: 8px;
      font-size: 13px;
      font-weight: 600;
      color: #667eea;
      letter-spacing: 0.3px;
      transition: all 0.3s ease;
      position: relative;
      box-shadow: 0 0 0 2px transparent;
      height: 28px;
    }

    .chat-toggle-btn::before {
      content: '';
      position: absolute;
      top: -1.5px;
      left: -1.5px;
      right: -1.5px;
      bottom: -1.5px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      z-index: -1;
    }

    .chat-toggle-btn:hover {
      box-shadow: 0 2px 12px rgba(102, 126, 234, 0.25);
    }

    .chat-toggle-btn:active {
      box-shadow: 0 1px 4px rgba(102, 126, 234, 0.2);
    }

    /* Record button */
    .record-btn {
      border: none;
      background: white;
      border-radius: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 14px;
      margin-left: 8px;
      font-size: 13px;
      font-weight: 600;
      color: #5f6368;
      letter-spacing: 0.3px;
      transition: all 0.3s ease;
      position: relative;
      box-shadow: 0 0 0 2px transparent;
      height: 28px;
      gap: 6px;
    }

    .record-btn::before {
      content: '';
      position: absolute;
      top: -1.5px;
      left: -1.5px;
      right: -1.5px;
      bottom: -1.5px;
      background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);
      border-radius: 16px;
      z-index: -1;
    }

    .record-btn:hover {
      box-shadow: 0 2px 12px rgba(107, 114, 128, 0.25);
    }

    .record-btn:active {
      box-shadow: 0 1px 4px rgba(107, 114, 128, 0.2);
    }

    .record-btn.recording {
      color: #dc2626;
    }

    .record-btn.recording::before {
      background: linear-gradient(135deg, #fca5a5 0%, #dc2626 100%);
    }

    .record-icon {
      font-size: 16px;
      display: inline-block;
    }

    .record-btn.recording .record-icon {
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .record-status {
      font-size: 12px;
    }

    /* Chat UI iframe - Ïò§Î•∏Ï™Ω 25% */
    .chat-iframe {
      position: fixed;
      right: 0;
      top: 0; /* Îß® ÏúÑÎ∂ÄÌÑ∞ ÏãúÏûë (Ï±ÑÌåÖ ÌÉ≠Î∞îÎèÑ ÏÉÅÎã® 32pxÏóê Ìè¨Ìï®) */
      width: 25%;
      height: 100vh;
      border: none;
      z-index: 1000;
      transition: transform 0.15s ease-out, opacity 0.15s ease-out;
    }

    .chat-iframe.hidden {
      transform: translateX(100%);
      opacity: 0;
      pointer-events: none;
    }

    /* Toolbar ÌÅ¨Í∏∞ Ï°∞Ï†ï - chat Ïà®Í∏∞Î©¥ 100% */
    .browser-toolbar.full-width {
      width: 100%;
    }

    /* Tab bar */
    .tab-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%; /* Ï†ÑÏ≤¥ ÎÑàÎπÑ */
      height: 32px;
      background: #e8eaed;
      display: flex;
      align-items: center;
      gap: 0; /* Î∏åÎûúÎìúÏôÄ ÌÉ≠ ÏÇ¨Ïù¥ Íµ¨Î∂Ñ */
      padding: 0;
      padding-right: 150px; /* ÏúàÎèÑÏö∞ Ïª®Ìä∏Î°§ Î≤ÑÌäº Í≥µÍ∞Ñ ÌôïÎ≥¥ */
      overflow-x: auto;
      overflow-y: hidden;
      z-index: 10001;
      -webkit-app-region: drag; /* ÌÉÄÏù¥ÌãÄÎ∞îÏ≤òÎüº ÎìúÎûòÍ∑∏ Í∞ÄÎä• */
    }

    /* macOS: Add left padding for traffic light buttons */
    .tab-bar.macos {
      padding-left: 78px; /* Space for macOS window controls (red, yellow, green) */
    }

    /* Cobalt Î∏åÎûúÎìú Î°úÍ≥† */
    .cobalt-brand {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 16px;
      height: 100%;
      background: transparent;
      border-right: 1px solid #dadce0;
      flex-shrink: 0; /* ÌÅ¨Í∏∞ Í≥†Ï†ï */
      -webkit-app-region: drag; /* ÎìúÎûòÍ∑∏ Í∞ÄÎä• */
    }

    .cobalt-logo {
      width: 20px;
      height: 20px;
      object-fit: contain;
    }

    .cobalt-text {
      font-size: 14px;
      font-weight: 600;
      color: #202124;
      letter-spacing: 0.5px;
      user-select: none;
    }

    /* ÌÉ≠ Ïª®ÌÖåÏù¥ÎÑà */
    .tabs-container {
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 0 4px;
      flex: 1; /* ÎÇ®ÏùÄ Í≥µÍ∞Ñ Ï∞®ÏßÄ */
      overflow-x: auto;
    }

    .tab {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: transparent;
      cursor: grab;
      width: 180px;
      font-size: 13px;
      color: #5f6368;
      user-select: none;
      transition: background 0.15s, transform 0.15s, box-shadow 0.15s;
      position: relative;
      -webkit-app-region: no-drag; /* ÌÉ≠ÏùÄ ÌÅ¥Î¶≠ Í∞ÄÎä• */
    }

    .tab:not(.active)::after {
      content: '';
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 1px;
      height: 16px;
      background: #dadce0;
    }

    .tab:hover:not(.active) {
      background: #e8eaed;
    }

    .tab.active {
      background: #fff;
      color: #202124;
      border-radius: 8px 8px 0 0;
      border-top: 1px solid #dadce0;
      border-left: 1px solid #dadce0;
      border-right: 1px solid #dadce0;
      border-bottom: 1px solid #fff;
      position: relative;
      z-index: 1;
    }

    .tab.active::after {
      display: none;
    }

    .tab.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .tab.drag-over {
      transform: translateX(4px);
    }

    .tab-favicon {
      width: 16px;
      height: 16px;
      object-fit: contain;
      flex-shrink: 0;
    }

    .tab-title {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tab-close {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      opacity: 0.6;
      transition: opacity 0.2s, background 0.2s;
    }

    .tab-close:hover {
      opacity: 1;
      background: rgba(0,0,0,0.1);
    }

    .new-tab-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: rgba(255,255,255,0.2);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #3c4043;
      transition: background 0.15s, transform 0.15s;
      -webkit-app-region: no-drag; /* Î≤ÑÌäºÏùÄ ÌÅ¥Î¶≠ Í∞ÄÎä• */
    }

    .new-tab-btn:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.1);
    }

    .new-tab-btn:active {
      transform: scale(0.95);
    }

    /* Find-in-page bar */
    .find-bar {
      position: fixed;
      top: 32px; /* under tab bar */
      right: 8px;
      height: 32px;
      display: none;
      align-items: center;
      gap: 8px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 16px;
      padding: 0 8px;
      z-index: 10002;
      box-shadow: 0 1px 6px rgba(32,33,36,.18);
    }
    .find-input {
      width: 220px;
      border: none;
      outline: none;
      font-size: 13px;
      background: transparent;
      color: #202124;
    }
    .find-counter {
      font-size: 12px;
      color: #5f6368;
      min-width: 48px;
      text-align: right;
    }
    .find-btn {
      border: none;
      background: #f1f3f4;
      color: #3c4043;
      border-radius: 12px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }
    .find-btn:hover { background: #e8eaed; }

    /* Status bar (link preview) */
    .status-bar {
      position: fixed;
      left: 8px;
      bottom: 8px;
      padding: 4px 8px;
      background: rgba(255,255,255,0.96);
      color: #202124;
      border: 1px solid #dadce0;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      font-size: 12px;
      max-width: 50%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      z-index: 9999;
      display: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Tab bar -->
  <div class="tab-bar" id="tabBar">
    <!-- Cobalt Î∏åÎûúÎìú Î°úÍ≥† -->
    <div class="cobalt-brand">
      <img src="cobalt_logo.png" alt="Cobalt" class="cobalt-logo">
      <span class="cobalt-text">Cobalt</span>
    </div>

    <!-- ÌÉ≠ Ïª®ÌÖåÏù¥ÎÑà -->
    <div class="tabs-container" id="tabsContainer">
      <div class="tab active" data-tab-id="0" draggable="true">
        <img class="tab-favicon" id="tab-favicon-0" src="cobalt_logo.png" alt="">
        <span class="tab-title" id="tab-title-0">New Tab</span>
        <span class="tab-close">√ó</span>
      </div>
      <button class="new-tab-btn" id="newTabBtn">+</button>
    </div>
  </div>

  <div class="browser-toolbar" id="toolbar">
    <button class="nav-button" id="backBtn" title="Back">‚Äπ</button>
    <button class="nav-button" id="forwardBtn" title="Forward">‚Ä∫</button>
    <button class="nav-button" id="refreshBtn" title="Reload">‚Üª</button>

    <div class="url-container">
      <span class="url-icon" id="urlIcon">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="5" y="11" width="14" height="10" rx="2" ry="2"/>
          <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
        </svg>
      </span>
      <input
        type="text"
        class="url-input"
        id="urlInput"
        placeholder="Search or enter a URL"
      />
      <button class="url-clear-btn" id="urlClearBtn" title="Clear">√ó</button>
    </div>

    <button class="record-btn" id="recordBtn" title="Record Macro">
      <span class="record-icon">‚è∫</span>
      <span class="record-status">Record</span>
    </button>

    <button class="chat-toggle-btn" id="chatToggleBtn" title="Toggle AI Chat">
      AI Chat
    </button>
  </div>

  <!-- Omnibox dropdown overlay (rendered in a separate BrowserView) -->

  <!-- Find in page bar -->
  <div class="find-bar" id="findBar">
    <input type="text" id="findInput" class="find-input" placeholder="Find in page" />
    <span class="find-counter" id="findCounter"></span>
    <button class="find-btn" id="findPrevBtn">Prev</button>
    <button class="find-btn" id="findNextBtn">Next</button>
    <button class="find-btn" id="findCloseBtn">‚úï</button>
  </div>

  <!-- Chat UI iframe -->
  <iframe src="browser-chat-ui.html" class="chat-iframe hidden" id="chatIframe"></iframe>
  <div class="status-bar" id="statusBar"></div>

  <script>
    const { ipcRenderer } = require('electron');
    const { platform } = require('os');

    const backBtn = document.getElementById('backBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const urlInput = document.getElementById('urlInput');
    const urlClearBtn = document.getElementById('urlClearBtn');
    const recordBtn = document.getElementById('recordBtn');
    const chatToggleBtn = document.getElementById('chatToggleBtn');
    const chatIframe = document.getElementById('chatIframe');
    const toolbar = document.getElementById('toolbar');
    const tabBar = document.getElementById('tabBar');
    const urlContainer = document.querySelector('.url-container');

    // Detect macOS and add class for styling (run after tabBar is defined)
    if (platform() === 'darwin' && tabBar) {
      tabBar.classList.add('macos');
    }
    const tabsContainer = document.getElementById('tabsContainer');
    const newTabBtn = document.getElementById('newTabBtn');
    const statusBar = document.getElementById('statusBar');
    const findBar = document.getElementById('findBar');
    const findInput = document.getElementById('findInput');
    const findCounter = document.getElementById('findCounter');
    const findPrevBtn = document.getElementById('findPrevBtn');
    const findNextBtn = document.getElementById('findNextBtn');
    const findCloseBtn = document.getElementById('findCloseBtn');

    let chatVisible = false;
    let isRecording = false;
    let currentTabId = 0;
    // Ï¥àÍ∏∞ ÌÉ≠Ïùò URLÏùÑ Ï†àÎåÄ Í≤ΩÎ°úÎ°ú ÏÑ§Ï†ï
    const homePageUrl = `file:///${__dirname.replace(/\\/g, '/')}/cobalt-home.html`;
    // Ï¥àÍ∏∞ ÌÉ≠ÏùÄ Cobalt Î°úÍ≥†Î°ú ÏãúÏûë
    let tabs = [{ id: 0, title: 'New Tab', url: homePageUrl, favicon: 'cobalt_logo.png' }];
    let nextTabId = 1;

    // ==================
    // Simple History DB
    // ==================
    const HISTORY_KEY = 'nav_history_v1';
    let historyStore = [];

    function loadHistory() {
      try {
        const raw = localStorage.getItem(HISTORY_KEY);
        historyStore = raw ? JSON.parse(raw) : [];
        if (!Array.isArray(historyStore)) historyStore = [];
      } catch (_) { historyStore = []; }
    }

    function saveHistory() {
      try { localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore)); } catch (_) {}
    }

    function isHttpUrl(u) {
      try { const p = new URL(u); return p.protocol === 'http:' || p.protocol === 'https:'; } catch { return false; }
    }

    function addHistoryEntry(url, title) {
      if (!isHttpUrl(url)) return;
      const now = Date.now();
      const idx = historyStore.findIndex(h => h.url === url);
      if (idx >= 0) {
        historyStore[idx].title = title || historyStore[idx].title || url;
        historyStore[idx].lastVisit = now;
        historyStore[idx].count = (historyStore[idx].count || 0) + 1;
      } else {
        historyStore.unshift({ url, title: title || url, lastVisit: now, count: 1 });
        // Cap history size
        if (historyStore.length > 500) historyStore.length = 500;
      }
      saveHistory();
    }

    function getHistorySuggestions(query, limit = 6) {
      const q = (query || '').toLowerCase();
      const list = historyStore
        .filter(h => {
          if (!h || !h.url) return false;
          if (!q) return true;
          return (h.title || '').toLowerCase().includes(q) || h.url.toLowerCase().includes(q);
        })
        .sort((a, b) => (b.lastVisit || 0) - (a.lastVisit || 0));
      const unique = [];
      const seen = new Set();
      for (const h of list) {
        if (seen.has(h.url)) continue;
        seen.add(h.url);
        unique.push({
          type: 'history',
          title: h.title || h.url,
          url: h.url,
          icon: getFaviconUrl(h.url)
        });
        if (unique.length >= limit) break;
      }
      return unique;
    }

    function removeHistoryByUrl(url) {
      if (!url) return;
      try {
        historyStore = (historyStore || []).filter(h => h && h.url !== url);
        saveHistory();
      } catch (_) {}
      // Refresh dropdown items (overlay will briefly hide itself and resync hover)
      try {
        const val = urlInput.value || '';
        const items = composeOmniboxItems(val);
        ipcRenderer.invoke('omnibox-set-items', { items, query: val }).catch(() => {});
      } catch (_) {}
    }

    // ==================
    // Inline suggestion
    // ==================
    let inlineSuggestion = null; // string of full suggestion placed in input
    let inlineTyped = '';        // what the user typed before applying suggestion

    function normalizeForMatch(url) {
      try {
        let s = url.toLowerCase();
        s = s.replace(/^https?:\/\//, '');
        s = s.replace(/^www\./, '');
        return s;
      } catch { return url || ''; }
    }

    function bestInlineSuggestion(typed) {
      const t = (typed || '').trim();
      if (!t) return null;
      if (/\s/.test(t)) return null; // don't inline for queries with spaces

      const candidates = getHistorySuggestions(t, 20);
      const nt = normalizeForMatch(t);
      for (const c of candidates) {
        if (!c || !c.url) continue;
        const nurl = normalizeForMatch(c.url);
        // Only inline if the normalized target starts with what the user typed
        if (nurl.startsWith(nt)) {
          return { full: c.url, display: nurl };
        }
      }
      // Do not inline-inject prefixes like https://; only show when we can append a suffix to the typed value
      return null;
    }

    function applyInlineSuggestionIfAny() {
      const el = urlInput;
      const typed = el.value;
      // Only when caret at end and no selection
      if (el.selectionStart !== el.selectionEnd || el.selectionStart !== typed.length) {
        inlineSuggestion = null; inlineTyped = '';
        return;
      }
      const candidate = bestInlineSuggestion(typed);
      if (!candidate) {
        inlineSuggestion = null; inlineTyped = '';
        return;
      }
      inlineSuggestion = candidate.full;
      inlineTyped = typed;
      // Build display by appending only the completion suffix to what the user typed
      const suffix = candidate.display.substring(typed.length);
      el.value = typed + suffix;
      el.setSelectionRange(typed.length, (typed + suffix).length);
    }

    // === Tab Persistence (save/restore across app restarts) ===
    function saveTabsState() {
      try {
        const state = { tabs, currentTabId, nextTabId };
        localStorage.setItem('tabs_state', JSON.stringify(state));
      } catch (_) { /* ignore */ }
    }

    function restoreTabsStateIfAny() {
      try {
        const raw = localStorage.getItem('tabs_state');
        if (!raw) return false;
        const state = JSON.parse(raw);
        if (!state || !Array.isArray(state.tabs) || state.tabs.length === 0) return false;

        // Reset UI and internal arrays
        tabs = state.tabs.map(t => ({ id: t.id, title: t.title || 'New Tab', url: t.url || homePageUrl, favicon: t.favicon || 'cobalt_logo.png' }));
        currentTabId = typeof state.currentTabId === 'number' ? state.currentTabId : tabs[0].id;
        nextTabId = typeof state.nextTabId === 'number' ? state.nextTabId : Math.max(...tabs.map(t => t.id)) + 1;

        // Clear existing tab elements except the "+" button
        document.querySelectorAll('.tab').forEach(el => el.remove());

        // Rebuild tab UI
        for (const t of tabs) {
          const tabElement = document.createElement('div');
          tabElement.className = 'tab';
          tabElement.setAttribute('data-tab-id', t.id);
          tabElement.setAttribute('draggable', 'true');
          tabElement.innerHTML = `
            <img class="tab-favicon" id="tab-favicon-${t.id}" src="${t.favicon || getFaviconUrl(t.url)}" alt="">
            <span class="tab-title" id="tab-title-${t.id}">${t.title || 'New Tab'}</span>
            <span class="tab-close">√ó</span>
          `;
          tabElement.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab-close')) {
              closeTab(t.id);
            } else {
              switchTab(t.id);
            }
          });
          setupTabDragEvents(tabElement, t.id);
          tabsContainer.insertBefore(tabElement, newTabBtn);
        }

        // If the initial default tab (0) is not in saved state, ask main to close it
        if (!tabs.some(t => t.id === 0)) {
          try { ipcRenderer.invoke('close-tab', { tabId: 0 }); } catch (_) {}
        }

        // Switch to the saved current tab and force URL restore
        const current = tabs.find(t => t.id === currentTabId) || tabs[0];
        if (current) {
          ipcRenderer.invoke('switch-tab', { tabId: current.id, url: current.url, restore: true }).catch(() => {});
        }

        // Do not auto-add an extra startup tab on restore.

        // Mark active tab visually
        document.querySelectorAll('.tab').forEach(tab => {
          const tabIdAttr = parseInt(tab.getAttribute('data-tab-id'));
          if (tabIdAttr === currentTabId) tab.classList.add('active'); else tab.classList.remove('active');
        });

        saveTabsState();
        return true;
      } catch (_) { return false; }
    }

    // Í∏∞Î≥∏ favicon (Îπà ÌéòÏù¥ÏßÄÏö©)
    const defaultFavicon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext x='8' y='12' text-anchor='middle' font-size='12'%3EüìÑ%3C/text%3E%3C/svg%3E";

    // Favicon Ï∂îÏ∂ú Ìï®Ïàò
    function getFaviconUrl(url) {
      try {
        const urlObj = new URL(url);
        if (urlObj.protocol === 'about:' || urlObj.protocol === 'file:') {
          return defaultFavicon;
        }
        return `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
      } catch {
        return defaultFavicon;
      }
    }

    // Ï¥àÍ∏∞ ÏÉÅÌÉú ÏÑ§Ï†ï (Ï±ÑÌåÖ Îã´Ìûå ÏÉÅÌÉú) + ensure main process layout is full width
    toolbar.classList.add('full-width');
    tabBar.classList.add('full-width');
    chatIframe.classList.add('hidden');
    chatVisible = false;
    try { ipcRenderer.invoke('toggle-chat', { visible: false }); } catch (_) {}

    // Attempt to restore tabs from last session
    restoreTabsStateIfAny();
    // Load history from previous sessions
    loadHistory();

    // Close omnibox when clicking inside the chat iframe
    chatIframe.addEventListener('load', () => {
      try {
        const doc = chatIframe.contentWindow && chatIframe.contentWindow.document;
        if (doc) {
          doc.addEventListener('mousedown', () => closeOmniboxDropdown());
        }
      } catch (_) {}
    });

    // Record Î≤ÑÌäº ÌÜ†Í∏Ä
    recordBtn.addEventListener('click', async () => {
      if (!isRecording) {
        // Start recording
        console.log('[Toolbar] Starting macro recording');

        const result = await ipcRenderer.invoke('macro-start-recording', { name: 'New Macro' });

        if (result.success) {
          isRecording = true;
          recordBtn.classList.add('recording');
          recordBtn.querySelector('.record-status').textContent = 'Recording...';
          console.log('[Toolbar] Recording started successfully');
        } else {
          console.error('[Toolbar] Failed to start recording:', result.error);
          alert('Failed to start recording: ' + result.error);
        }
      } else {
        // Stop recording
        console.log('[Toolbar] Stopping macro recording');

        const result = await ipcRenderer.invoke('macro-stop-recording');

        if (result.success) {
          isRecording = false;
          recordBtn.classList.remove('recording');
          recordBtn.querySelector('.record-status').textContent = 'Record';
          console.log('[Toolbar] Recording stopped successfully');
          console.log('[Toolbar] Recorded events:', result.events?.length || 0);

          // Open flowchart viewer with recorded macro
          if (result.macro && result.events && result.events.length > 0) {
            console.log('[Toolbar] Opening flowchart viewer');
            ipcRenderer.invoke('macro-show-flowchart', result.macro);
          } else {
            alert('No events were recorded. Try recording some actions on the page.');
          }
        } else {
          console.error('[Toolbar] Failed to stop recording:', result.error);
          alert('Failed to stop recording: ' + result.error);
        }
      }
    });

    // Chat ÌÜ†Í∏Ä
    chatToggleBtn.addEventListener('click', () => {
      chatVisible = !chatVisible;

      if (chatVisible) {
        chatIframe.classList.remove('hidden');
        toolbar.classList.remove('full-width');
        tabBar.classList.remove('full-width');
        ipcRenderer.invoke('toggle-chat', { visible: true });
      } else {
        chatIframe.classList.add('hidden');
        toolbar.classList.add('full-width');
        tabBar.classList.add('full-width');
        ipcRenderer.invoke('toggle-chat', { visible: false });
      }

      // Reposition dropdown overlay if open
      const b = omniboxBounds();
      if (b) ipcRenderer.invoke('omnibox-update', b).catch(() => {});
    });

    // ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ Í¥ÄÎ†® Î≥ÄÏàò
    let draggedTab = null;
    let draggedTabId = null;
    let isCreatingTab = false; // Prevent duplicate tab creation

    // ÌÉ≠ ÏÉùÏÑ±
    function createNewTab() {
      // Prevent duplicate calls
      if (isCreatingTab) {
        console.warn('[Toolbar] Tab creation already in progress, ignoring duplicate call');
        return;
      }

      isCreatingTab = true;

      try {
        const tabId = nextTabId++;
        console.log('[Toolbar] Creating new tab with ID:', tabId);
        console.log('[Toolbar] Current tabs before creation:', tabs.map(t => ({ id: t.id, title: t.title })));

        // Check if tab already exists in DOM
        const existingTab = document.querySelector(`[data-tab-id="${tabId}"]`);
        if (existingTab) {
          console.error('[Toolbar] Tab with ID', tabId, 'already exists in DOM! Aborting.');
          nextTabId--; // Rollback ID
          return;
        }

        // Check if tab already exists in array
        const existingInArray = tabs.find(t => t.id === tabId);
        if (existingInArray) {
          console.error('[Toolbar] Tab with ID', tabId, 'already exists in array! Aborting.');
          nextTabId--; // Rollback ID
          return;
        }

        // ÏÉà ÌÉ≠ÎèÑ Cobalt Î°úÍ≥†Î°ú ÏãúÏûë
        tabs.push({ id: tabId, title: 'New Tab', url: homePageUrl, favicon: 'cobalt_logo.png' });
        console.log('[Toolbar] Tab added to array. Total tabs:', tabs.length);

        const tabElement = document.createElement('div');
        tabElement.className = 'tab';
        tabElement.setAttribute('data-tab-id', tabId);
        tabElement.setAttribute('draggable', 'true');
        tabElement.innerHTML = `
          <img class="tab-favicon" id="tab-favicon-${tabId}" src="cobalt_logo.png" alt="">
          <span class="tab-title" id="tab-title-${tabId}">New Tab</span>
          <span class="tab-close">√ó</span>
        `;

        tabElement.addEventListener('click', (e) => {
          if (e.target.classList.contains('tab-close')) {
            closeTab(tabId);
          } else {
            switchTab(tabId);
          }
        });

        // ÎìúÎûòÍ∑∏ Ïù¥Î≤§Ìä∏
        setupTabDragEvents(tabElement, tabId);

        tabsContainer.insertBefore(tabElement, newTabBtn);
        console.log('[Toolbar] Tab element added to DOM. DOM tabs count:', document.querySelectorAll('.tab').length);

        switchTab(tabId);
        saveTabsState();
      } finally {
        // Reset flag after a short delay to allow the operation to complete
        setTimeout(() => {
          isCreatingTab = false;
        }, 100);
      }
    }

    // ÌÉ≠ ÎìúÎûòÍ∑∏ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
    function setupTabDragEvents(tabElement, tabId) {
      tabElement.addEventListener('dragstart', (e) => {
        draggedTab = tabElement;
        draggedTabId = tabId;
        tabElement.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
      });

      tabElement.addEventListener('dragend', (e) => {
        tabElement.classList.remove('dragging');
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('drag-over'));
      });

      tabElement.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (draggedTab && draggedTab !== tabElement) {
          tabElement.classList.add('drag-over');
        }
      });

      tabElement.addEventListener('dragleave', (e) => {
        tabElement.classList.remove('drag-over');
      });

      tabElement.addEventListener('drop', (e) => {
        e.preventDefault();
        tabElement.classList.remove('drag-over');

        if (draggedTab && draggedTab !== tabElement) {
          // Î∞∞Ïó¥ÏóêÏÑú ÌÉ≠ ÏàúÏÑú Î≥ÄÍ≤Ω
          const draggedIndex = tabs.findIndex(t => t.id === draggedTabId);
          const targetIndex = tabs.findIndex(t => t.id === tabId);

          if (draggedIndex !== -1 && targetIndex !== -1) {
            const [movedTab] = tabs.splice(draggedIndex, 1);
            tabs.splice(targetIndex, 0, movedTab);

            // DOMÏóêÏÑú ÏàúÏÑú Î≥ÄÍ≤Ω
            const targetTab = tabElement;
            if (draggedIndex < targetIndex) {
              targetTab.parentNode.insertBefore(draggedTab, targetTab.nextSibling);
            } else {
              targetTab.parentNode.insertBefore(draggedTab, targetTab);
            }
          }
        }
      });
      // Persist order after drop
      saveTabsState();
    }

    // ÌÉ≠ Ï†ÑÌôò
    function switchTab(tabId) {
      console.log('[Toolbar] Switching to tab:', tabId);
      console.log('[Toolbar] Current tab before switch:', currentTabId);

      currentTabId = tabId;

      // UI ÏóÖÎç∞Ïù¥Ìä∏
      document.querySelectorAll('.tab').forEach(tab => {
        const tabIdAttr = parseInt(tab.getAttribute('data-tab-id'));
        if (tabIdAttr === tabId) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });

      // ÌÉ≠ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
      const tab = tabs.find(t => t.id === tabId);
      if (!tab) {
        console.error('[Toolbar] Tab not found in array:', tabId);
        return;
      }

      console.log('[Toolbar] Tab info:', { id: tab.id, title: tab.title, url: tab.url });

      if (tab.url) {
        // URLÏù¥ ÎπÑÏñ¥ÏûàÏßÄ ÏïäÏùÄÏßÄ ÌôïÏù∏
        const urlToLoad = tab.url.startsWith('http') || tab.url.startsWith('file://')
          ? tab.url
          : homePageUrl;

        console.log('[Toolbar] Invoking switch-tab with URL:', urlToLoad);
        ipcRenderer.invoke('switch-tab', { tabId, url: urlToLoad })
          .then(() => {
            console.log('[Toolbar] Successfully switched to tab:', tabId);
          })
          .catch(err => {
            console.error('[Toolbar] Failed to switch tab:', err);
          });
      }
      // Persist active tab change
      saveTabsState();
    }

    // ÌÉ≠ Îã´Í∏∞
    function closeTab(tabId) {
      console.log('[Toolbar] Closing tab:', tabId);
      console.log('[Toolbar] Current tabs before close:', tabs.map(t => ({ id: t.id, title: t.title })));

      if (tabs.length === 1) {
        alert('The last tab cannot be closed.');
        return;
      }

      // Notify electron to destroy the BrowserView
      ipcRenderer.invoke('close-tab', { tabId }).catch(err => {
        console.error('[Toolbar] Failed to close tab in electron:', err);
      });

      // ÌÉ≠ Ï†úÍ±∞
      tabs = tabs.filter(t => t.id !== tabId);
      const tabElement = tabBar.querySelector(`[data-tab-id="${tabId}"]`);
      if (tabElement) {
        tabElement.remove();
        console.log('[Toolbar] Tab element removed from DOM');
      }

      console.log('[Toolbar] Tabs after close:', tabs.map(t => ({ id: t.id, title: t.title })));
      console.log('[Toolbar] DOM tabs count:', document.querySelectorAll('.tab').length);

      // ÌòÑÏû¨ ÌÉ≠Ïù¥ Îã´Ìûå Í≤ΩÏö∞ Îã§Î•∏ ÌÉ≠ÏúºÎ°ú Ï†ÑÌôò
      if (currentTabId === tabId) {
        const nextTab = tabs[tabs.length - 1]; // Switch to last tab
        if (nextTab) {
          console.log('[Toolbar] Switching to tab:', nextTab.id);
          switchTab(nextTab.id);
        }
      }
      // Persist after close
      saveTabsState();
    }

    // Initialize first tab with event listeners
    function initializeFirstTab() {
      const firstTab = document.querySelector('.tab[data-tab-id="0"]');
      if (firstTab) {
        // Remove any existing listeners by cloning
        const newFirstTab = firstTab.cloneNode(true);
        firstTab.parentNode.replaceChild(newFirstTab, firstTab);

        // Add click event
        newFirstTab.addEventListener('click', (e) => {
          if (e.target.classList.contains('tab-close')) {
            closeTab(0);
          } else {
            switchTab(0);
          }
        });

        // Add drag events
        setupTabDragEvents(newFirstTab, 0);

        console.log('[Toolbar] First tab initialized');
      }
    }

    // Initialize first tab
    initializeFirstTab();

    // ÏÉà ÌÉ≠ Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏
    newTabBtn.addEventListener('click', createNewTab);

    // Îí§Î°ú Í∞ÄÍ∏∞
    backBtn.addEventListener('click', () => {
      ipcRenderer.invoke('browser-navigation', { action: 'back' });
    });

    // ÏïûÏúºÎ°ú Í∞ÄÍ∏∞
    forwardBtn.addEventListener('click', () => {
      ipcRenderer.invoke('browser-navigation', { action: 'forward' });
    });

    // ÏÉàÎ°úÍ≥†Ïπ®
    refreshBtn.addEventListener('click', () => {
      ipcRenderer.invoke('browser-navigation', { action: 'reload' });
    });

    // URL ÏûÖÎ†• (Enter ÌÇ§)
    urlInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        // If inline suggestion exists, prefer it
        if (inlineSuggestion) {
          ipcRenderer.invoke('browser-navigation', { action: 'navigate', url: inlineSuggestion });
          closeOmniboxDropdown();
          return;
        }
        let url = urlInput.value.trim();

        // If a suggestion is selected, prefer it
        try {
          if (typeof omniboxSelected === 'object' && omniboxSelected && omniboxSelected.url) {
            ipcRenderer.invoke('browser-navigation', { action: 'navigate', url: omniboxSelected.url });
            closeOmniboxDropdown();
            return;
          }
        } catch (_) {}

        // Ï£ºÏÜåÏ∞ΩÏù¥ ÎπÑÏñ¥ÏûàÏúºÎ©¥ Ìôà ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
        if (!url) {
          ipcRenderer.invoke('browser-navigation', { action: 'navigate', url: homePageUrl });
          return;
        }

        // URLÏù¥ ÏïÑÎãàÎ©¥ Google Í≤ÄÏÉâÏúºÎ°ú Ï≤òÎ¶¨
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
          if (url.includes('.') && !url.includes(' ')) {
            // domain.com ÌòïÌÉúÎ©¥ https Ï∂îÍ∞Ä
            url = 'https://' + url;
          } else {
            // Í≤ÄÏÉâÏñ¥Î°ú Ï≤òÎ¶¨
            url = 'https://www.google.com/search?q=' + encodeURIComponent(url);
          }
        }

        ipcRenderer.invoke('browser-navigation', { action: 'navigate', url });
        // Close omnibox on navigation
        closeOmniboxDropdown();
      }
    });

    // -------------------------------
    // Omnibox dropdown open/close
    // -------------------------------
    function omniboxBounds() {
      if (!urlContainer) return null;
      const rect = urlContainer.getBoundingClientRect();
      return {
        x: Math.round(rect.left),
        y: Math.round(rect.bottom),
        width: Math.round(rect.width),
        height: 320,
      };
    }

    // No extra space is reserved; dropdown overlays the content.

    function buildOmniboxItems(query) {
      const items = [];
      const q = (query || '').trim();
      const isProbablyUrl = /^(https?:\/\/|file:\/\/|about:|localhost|\S+\.\S{2,})/.test(q);
      const hasSpace = /\s/.test(q);
      const normalizedUrl = (() => {
        if (!q) return '';
        if (/^https?:\/\//i.test(q)) return q;
        if (q.startsWith('file://') || q.startsWith('about:')) return q;
        if (!hasSpace && (q.includes('.') || q.startsWith('localhost'))) return 'https://' + q;
        return '';
      })();
      if (q && normalizedUrl) {
        items.push({ type: 'go', title: `Go to ${q}`, url: normalizedUrl, icon: `https://www.google.com/s2/favicons?domain=${encodeURIComponent(q.replace(/^https?:\/\//,''))}&sz=32` });
      }
      if (q) {
        items.push({ type: 'search', title: `Search Google for "${q}"`, url: `https://www.google.com/search?q=${encodeURIComponent(q)}`, icon: '', action: 'search' });
      } else {
        items.push({ type: 'hint', title: 'Type to search or paste a URL' });
      }
      return items;
    }

    // Compose base items with history suggestions
    function composeOmniboxItems(query) {
      const base = buildOmniboxItems(query);
      const q = (query || '').trim();
      const hist = getHistorySuggestions(q, q ? 6 : 8);
      if (!q) {
        // If empty, prefer showing recent history; fallback to hint
        return hist.length ? hist : base;
      }
      return base.concat(hist);
    }

    function openOmniboxDropdown() {
      const b = omniboxBounds();
      if (!b) return;
      // Visually attach dropdown to the input
      urlContainer.classList.add('open');
      const items = composeOmniboxItems(urlInput.value || '');
      ipcRenderer.invoke('omnibox-open', { ...b, items }).then(() => {
        ipcRenderer.invoke('omnibox-set-items', { items, query: urlInput.value || '' });
      }).catch(() => {});
    }

    function closeOmniboxDropdown() {
      urlContainer.classList.remove('open');
      ipcRenderer.invoke('omnibox-close').catch(() => {});
    }

    urlInput.addEventListener('focus', () => { openOmniboxDropdown(); applyInlineSuggestionIfAny(); });
    urlInput.addEventListener('input', openOmniboxDropdown);
    urlInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        closeOmniboxDropdown();
        urlInput.blur();
      }
    });
    // Do not auto-close on blur to allow overlay interactions
    // Close overlay when the content (below) is clicked
    ipcRenderer.on('omnibox-close-request', () => {
      closeOmniboxDropdown();
    });
    // Remove history from overlay request
    ipcRenderer.on('omnibox-remove-history', (_e, url) => {
      removeHistoryByUrl(url);
    });
    // Close when clicking toolbar area outside the url container
    document.addEventListener('mousedown', (e) => {
      if (!urlContainer.contains(e.target)) {
        closeOmniboxDropdown();
      }
    });
    window.addEventListener('resize', () => {
      const b = omniboxBounds();
      if (b) ipcRenderer.invoke('omnibox-update', b).catch(() => {});
    });

    // Update overlay items as user types, and show clear button
    urlInput.addEventListener('input', () => {
      const val = urlInput.value || '';
      const items = composeOmniboxItems(val);
      ipcRenderer.invoke('omnibox-set-items', { items, query: val }).catch(() => {});
      openOmniboxDropdown();
      // toggle clear button
      urlClearBtn.style.display = val ? 'flex' : 'none';
      // inline suggestion
      applyInlineSuggestionIfAny();
    });

    // Clear input
    urlClearBtn.addEventListener('click', (e) => {
      e.preventDefault();
      urlInput.value = '';
      urlInput.focus();
      const items = composeOmniboxItems('');
      ipcRenderer.invoke('omnibox-set-items', { items, query: '' }).catch(() => {});
      openOmniboxDropdown();
      urlClearBtn.style.display = 'none';
    });

    // Keyboard navigation for suggestions + inline accept
    urlInput.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown') { e.preventDefault(); ipcRenderer.invoke('omnibox-key', 'down'); }
      else if (e.key === 'ArrowUp') { e.preventDefault(); ipcRenderer.invoke('omnibox-key', 'up'); }
      else if (e.key === 'Home' && (e.metaKey || e.ctrlKey)) { ipcRenderer.invoke('omnibox-key', 'home'); }
      else if (e.key === 'End' && (e.metaKey || e.ctrlKey)) { ipcRenderer.invoke('omnibox-key', 'end'); }
      else if (e.key === 'Tab') {
        if (inlineSuggestion) {
          e.preventDefault();
          // Accept inline suggestion: place caret at end
          urlInput.setSelectionRange(urlInput.value.length, urlInput.value.length);
          // Keep dropdown open with new query context
        }
      }
    });

    // Receive overlay selection changes and choose events
    let omniboxSelected = null;
    ipcRenderer.on('omnibox-selection', (_e, item) => { omniboxSelected = item || null; });
    ipcRenderer.on('omnibox-choose', (_e, item) => {
      if (item && item.url) {
        ipcRenderer.invoke('browser-navigation', { action: 'navigate', url: item.url });
        closeOmniboxDropdown();
      }
    });

    // ========================================
    // Lock address bar while AI navigates
    // ========================================
    function setNavLock(locked) {
      try {
        urlInput.disabled = !!locked;
        if (locked) {
          urlContainer.classList.add('disabled');
          closeOmniboxDropdown();
        } else {
          urlContainer.classList.remove('disabled');
        }
      } catch (_) {}
    }

    ipcRenderer.on('agent-started', (_e, _data) => {
      setNavLock(true);
    });
    ipcRenderer.on('agent-stopped', (_e, _data) => {
      setNavLock(false);
    });

    // BrowserView URL Î≥ÄÍ≤Ω Ïãú Ï£ºÏÜåÏ∞Ω ÏóÖÎç∞Ïù¥Ìä∏
    ipcRenderer.on('url-changed', (event, url, title) => {
      // cobalt-home.htmlÏùº ÎïåÎäî Ï£ºÏÜåÏ∞ΩÏùÑ ÎπÑÏõåÏÑú ÍπîÎÅîÌïòÍ≤å ÌëúÏãú
      const isCobaltHome = url.includes('cobalt-home.html');
      if (isCobaltHome) {
        urlInput.value = '';
      } else {
        urlInput.value = url;
      }

      // ÌòÑÏû¨ ÌÉ≠ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
      const currentTab = tabs.find(t => t.id === currentTabId);
      if (currentTab) {
        currentTab.url = url;
        currentTab.title = title || 'New Tab';

        // Favicon ÏóÖÎç∞Ïù¥Ìä∏ - cobalt-homeÏù¥Î©¥ Î°úÍ≥† ÏÇ¨Ïö©
        const faviconUrl = isCobaltHome ? 'cobalt_logo.png' : getFaviconUrl(url);
        currentTab.favicon = faviconUrl;

        // ÌÉ≠ Ï†úÎ™© ÏóÖÎç∞Ïù¥Ìä∏
        const tabTitleElement = document.getElementById(`tab-title-${currentTabId}`);
        if (tabTitleElement) {
          tabTitleElement.textContent = title || 'New Tab';
        }

        // Favicon Ïù¥ÎØ∏ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏
        const tabFaviconElement = document.getElementById(`tab-favicon-${currentTabId}`);
        if (tabFaviconElement) {
          tabFaviconElement.src = faviconUrl;
        }
      }

      // Record to history
      if (!isCobaltHome) {
        addHistoryEntry(url, title);
      }

      // Îí§Î°ú/ÏïûÏúºÎ°ú Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      ipcRenderer.invoke('browser-can-navigate').then(({ canGoBack, canGoForward }) => {
        backBtn.disabled = !canGoBack;
        forwardBtn.disabled = !canGoForward;
      });
    });

    // Forward agent events to chat iframe
    ipcRenderer.on('agent-started', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'agent-started', data }, '*');
    });

    ipcRenderer.on('agent-log', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'agent-log', data }, '*');
    });

    ipcRenderer.on('agent-stopped', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'agent-stopped', data }, '*');
    });

    ipcRenderer.on('agent-screenshot', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'agent-screenshot', data }, '*');
    });

    // Note: Legacy translate-text and ai-edit-text event handlers removed
    // These were unused - actual translation/editing handled via browserview-* IPC channels

    // Handle execute-home-search event
    console.log('[Toolbar] Registering execute-home-search listener');
    ipcRenderer.on('execute-home-search', async (event, query) => {
      console.log('[Toolbar] Execute home search received');
      console.log('[Toolbar] Query value:', query);
      console.log('[Toolbar] Query type:', typeof query);
      console.log('[Toolbar] Current chatVisible:', chatVisible);

      console.log('[Toolbar] Chat iframe found:', !!chatIframe);

      // Show chat if hidden
      if (!chatVisible) {
        console.log('[Toolbar] Opening chat...');
        chatVisible = true;
        chatIframe.classList.remove('hidden');
        toolbar.classList.remove('full-width');
        tabBar.classList.remove('full-width');
        await ipcRenderer.invoke('toggle-chat', { visible: true });
        console.log('[Toolbar] Chat opened, chatVisible now:', chatVisible);
      } else {
        console.log('[Toolbar] Chat already visible');
      }

      // Wait a bit for chat to be visible
      setTimeout(() => {
        console.log('[Toolbar] Sending execute-search to chat iframe');
        console.log('[Toolbar] Query being sent:', query);

        if (!chatIframe.contentWindow) {
          console.error('[Toolbar] Chat iframe contentWindow not available');
          return;
        }

        // Send message to chat iframe to create new tab and execute query
        chatIframe.contentWindow.postMessage({
          type: 'execute-search',
          query: query
        }, '*');
        console.log('[Toolbar] Message sent to chat iframe');
      }, 300);
    });

    // Handle tab-switched event from main process
    ipcRenderer.on('tab-switched', (event, { tabId }) => {
      console.log('[Toolbar] Tab switched event received, tabId:', tabId);

      // Update current tab ID
      currentTabId = tabId;

      // Update tab UI - remove active from all tabs, add to current
      document.querySelectorAll('.tab').forEach(tab => {
        const tabIdAttr = parseInt(tab.getAttribute('data-tab-id'));
        if (tabIdAttr === tabId) {
          tab.classList.add('active');
          console.log('[Toolbar] Set tab', tabId, 'as active');
        } else {
          tab.classList.remove('active');
        }
      });
    });

    // Handle create-new-tab event from main process (when user clicks links with target="_blank")
    ipcRenderer.on('create-new-tab', (event, { tabId, url }) => {
      console.log('[Toolbar] Create new tab event received, tabId:', tabId, 'url:', url);

      // Check if tab already exists
      const existingTab = tabs.find(t => t.id === tabId);
      if (existingTab) {
        console.log('[Toolbar] Tab already exists, switching to it');
        switchTab(tabId);
        return;
      }

      // Create new tab with the URL
      tabs.push({ id: tabId, title: 'Loading...', url: url, favicon: defaultFavicon });
      console.log('[Toolbar] Tab added to array. Total tabs:', tabs.length);

      const tabElement = document.createElement('div');
      tabElement.className = 'tab';
      tabElement.setAttribute('data-tab-id', tabId);
      tabElement.setAttribute('draggable', 'true');
      tabElement.innerHTML = `
        <img class="tab-favicon" id="tab-favicon-${tabId}" src="${defaultFavicon}" alt="">
        <span class="tab-title" id="tab-title-${tabId}">Loading...</span>
        <span class="tab-close">√ó</span>
      `;

      tabElement.addEventListener('click', (e) => {
        if (e.target.classList.contains('tab-close')) {
          closeTab(tabId);
        } else {
          switchTab(tabId);
        }
      });

      // Setup drag events
      setupTabDragEvents(tabElement, tabId);

      tabsContainer.insertBefore(tabElement, newTabBtn);
      console.log('[Toolbar] Tab element added to DOM. DOM tabs count:', document.querySelectorAll('.tab').length);

      // Switch to the new tab and load the URL
      switchTab(tabId, url);
      saveTabsState();
    });

    // Ï¥àÍ∏∞ ÌÉ≠Ïóê ÎìúÎûòÍ∑∏ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
    const initialTab = document.querySelector('.tab[data-tab-id="0"]');
    if (initialTab) {
      setupTabDragEvents(initialTab, 0);
    }

    // Ï¥àÍ∏∞ URL Î°úÎìú
    ipcRenderer.invoke('browser-get-url').then((url) => {
      if (url) urlInput.value = url;
    });

    // Focus address bar
    ipcRenderer.on('focus-address-bar', () => {
      urlInput.focus();
      urlInput.select();
    });

    // Open find bar
    ipcRenderer.on('open-find', () => {
      findBar.style.display = 'flex';
      setTimeout(() => findInput.focus(), 0);
    });

    function updateFindCounter(result) {
      if (!result) { findCounter.textContent = ''; return; }
      const { activeMatchOrdinal, matches } = result;
      if (typeof matches === 'number' && matches >= 0) {
        findCounter.textContent = `${activeMatchOrdinal || 0}/${matches}`;
      } else {
        findCounter.textContent = '';
      }
    }

    ipcRenderer.on('find-results', (_e, result) => {
      updateFindCounter(result);
    });

    function doFind(forward, findNext) {
      const query = findInput.value || '';
      ipcRenderer.invoke('find-in-page', { query, forward, findNext }).catch(() => {});
    }

    findInput.addEventListener('input', () => doFind(true, false));
    findInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        doFind(!e.shiftKey, true);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        findBar.style.display = 'none';
        ipcRenderer.invoke('stop-find-in-page');
      }
    });
    findPrevBtn.addEventListener('click', () => doFind(false, true));
    findNextBtn.addEventListener('click', () => doFind(true, true));
    findCloseBtn.addEventListener('click', () => {
      findBar.style.display = 'none';
      ipcRenderer.invoke('stop-find-in-page');
    });

    // Status bar link preview
    ipcRenderer.on('status-url', (_e, url) => {
      if (url) {
        statusBar.textContent = url;
        statusBar.style.display = 'block';
      } else {
        statusBar.style.display = 'none';
        statusBar.textContent = '';
      }
    });

    // Keep saved tabs in sync when the active tab's URL/title changes
    ipcRenderer.on('url-changed', (_e, url, title) => {
      try {
        const idx = tabs.findIndex(t => t.id === currentTabId);
        if (idx >= 0) {
          tabs[idx].url = url || tabs[idx].url;
          tabs[idx].title = title || tabs[idx].title;
          tabs[idx].favicon = getFaviconUrl(url || '');
          // Update UI too
          const tEl = document.getElementById(`tab-title-${currentTabId}`);
          if (tEl && title) tEl.textContent = title;
          const fEl = document.getElementById(`tab-favicon-${currentTabId}`);
          if (fEl) fEl.src = tabs[idx].favicon;
          saveTabsState();
        }
      } catch (_) { /* ignore */ }
    });

    // ========================================
    // Macro Execution - Forward to Chat UI
    // ========================================

    // Forward macro events to chat iframe (same as AI agent events)
    ipcRenderer.on('macro-started', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'macro-started', data }, '*');
    });

    ipcRenderer.on('macro-step-start', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'macro-step-start', data }, '*');
    });

    ipcRenderer.on('macro-step-complete', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'macro-step-complete', data }, '*');
    });

    ipcRenderer.on('macro-step-error', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'macro-step-error', data }, '*');
    });

    ipcRenderer.on('macro-screenshot', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'macro-screenshot', data }, '*');
    });

    ipcRenderer.on('macro-complete', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'macro-complete', data }, '*');
    });

    ipcRenderer.on('macro-stopped', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'macro-stopped', data }, '*');
    });

    ipcRenderer.on('macro-error', (event, data) => {
      chatIframe.contentWindow.postMessage({ type: 'macro-error', data }, '*');
    });

  </script>
</body>
</html>
    .url-clear-btn {
      appearance: none;
      border: none;
      background: transparent;
      color: #9aa0a6;
      width: 24px;
      height: 24px;
      border-radius: 12px;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }
    .url-clear-btn:hover { background: #eef2ff; color: #4f46e5; }
